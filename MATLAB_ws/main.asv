close all
% clear
clearvars -except UR_N100
clc

%% Cargar función que provee la penetración en Z y orientación deseadas
load('Testing_scripts/Plane_Fit.mat');

%% Include and create custom messages

folderPath = fullfile(pwd, "custom");
ros2genmsg(folderPath)

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Create MATLAB ROS 2 node
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Global variable for desired orientation in callback
global desiredQuat;

% Node
nodeMATLAB = ros2node("/MATLAB_Node", 0);

% Publishers
pub_pose = ros2publisher(nodeMATLAB,...
                    "/cartesian_compliance_controller/target_frame",...
                    "geometry_msgs/PoseStamped");
pub_wrench = ros2publisher(nodeMATLAB,...
                    "/cartesian_compliance_controller/target_wrench",...
                    "geometry_msgs/WrenchStamped");

% Publishers Message structure
msg_pose = ros2message(pub_pose);
msg_wrench = ros2message(pub_wrench);

% Subscribers
subs_pose = ros2subscriber(nodeMATLAB, ...
                          "/ee_pose_fast", ...         
                          "geometry_msgs/PoseStamped");

subs_data = ros2subscriber(nodeMATLAB, ...
                          "/synced_data", ...         
                          "custom_interfaces/SyncData");

subs_quat = ros2subscriber(nodeMATLAB, ...
                          "/ee_pose_fast", ...         
                          @(msg) CallbackQuat(msg, desiredOrientation));

% Callback for ensuring quaternion continuity
function CallbackQuat(message, desiredOrientation)
    global desiredQuat;
    q_last = [message.pose.orientation.x;
              message.pose.orientation.y;
              message.pose.orientation.z;
              message.pose.orientation.w];
    if (q_last'*desiredOrientation) < 0
        desiredQuat = - desiredOrientation;
    else
        desiredQuat = desiredOrientation;
    end
end


% Stop subscriber with callback
% clear subs_quat

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Drive UR to initial position
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Dimension Limits: x_1 = [0; 0.28] | x_2 = [0; 0.22]

% Initial position in X-Y plane
Pose_0 = [0.1; 0.1];

%Testing
% Pose_0 = [0.0; 0.0];

% Get current pose
[Current_pose, status, statusText] = receive(subs_pose, 10);

P_i = [Current_pose.pose.position.x;
       Current_pose.pose.position.y;
       Current_pose.pose.position.z;
       Current_pose.pose.orientation.x;
       Current_pose.pose.orientation.y;
       Current_pose.pose.orientation.z;
       Current_pose.pose.orientation.w];

% Desired Pose (with a fixed desired orientation)
P_f = [Pose_0(1); Pose_0(2); 0.05; desiredOrientation];

% Send trajectory to UR with a soft interpolation using Bezier
mvr_time = 5;
ur_traj_init(P_i, P_f, mvr_time, nodeMATLAB,...
               pub_pose, pub_wrench, msg_pose, msg_wrench);

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Drive UR to lifted position
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Get current pose
[Current_pose, status, statusText] = receive(subs_pose, 10);

% Get current position (NO orientation)
P_i = [Current_pose.pose.position.x;
       Current_pose.pose.position.y;
       Current_pose.pose.position.z];

% Desired Pose (with a fixed desired orientation)
P_f = [Pose_0(1); Pose_0(2); 0.05; desiredOrientation];

% Send trajectory to UR with a soft interpolation using Bezier
mvr_time = 5;
ur_traj_contact(P_i, P_f, mvr_time, 0, nodeMATLAB,...
               pub_pose, pub_wrench, msg_pose, msg_wrench);

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Drive UR to contact position
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[Current_pose, status, statusText] = receive(subs_pose, 10);

% Get current position (NO orientation)
P_i = [Current_pose.pose.position.x;
       Current_pose.pose.position.y;
       Current_pose.pose.position.z];

% Computes the z-coordinate needed to reach f = 5 N given interpolated
% data points
z_desired = desiredZ(Pose_0');

% Contact position
P_f = [Pose_0(1); Pose_0(2); z_desired];
f_z = 5.0;

% send trajectory to get in contact with the plane (The orientation is
% automatically updated in the callback and the contact function sends it)
ur_traj_contact(P_i, P_f, mvr_time, f_z, nodeMATLAB,...
               pub_pose, pub_wrench, msg_pose, msg_wrench);

%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Compute and send first ergodic trajectory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%% Crear distribución uniforme y obtener trayectoria




%%%% hacer un spline a la trayectoria y guardarla
% en Trayectoria = [t_spline, X_e, orientation]

%%%% Hacer una funcion Data = ur_send_traj(Trayectoria, parametros de nodo) 
% que ejecute la trayectoria en el robot real y guarde la información

%%%% filtrar datos

%%%% Crear nueva distribución (PDF_estimator)

TactExp_GMM
