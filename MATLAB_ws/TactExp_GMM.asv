
% CasADi
import casadi.*

% loading casadi function object (comment if it's already loaded)
UR_N100 = Function.load('CasADi_Formulation/UR_N100.casadi');

%% Parámetros del espacio de búsqueda 
% Omega = [L_1_l, L_1_u] \times [L_2_l, L_2_u]

% Número de dimensiones espaciales
n = 2; 

L_1_l = 0.16;
L_1_u = 0.44;
dx_1 = (L_1_u - L_1_l)/50;

L_2_l = 0.0;
L_2_u = 0.24;
dx_2 = (L_2_u - L_2_l)/50;

% Dimensiones \mathbf{x} = [x_1 x_2]^T
x_1 = (L_1_l:dx_1:L_1_u)';
x_2 = (L_2_l:dx_2:L_2_u)';

% vector de límites inferior y superiores de las dimensiones
L_i_l = [L_1_l, L_2_l];
L_i_u = [L_1_u, L_2_u];

% Longitudes
L_1 = L_1_u - L_1_l;
L_2 = L_2_u - L_2_l;

[x_1_grid, x_2_grid] = meshgrid(x_1, x_2);

% Espacio de búsqueda discretizado
Omega = [reshape(x_1_grid,[],1), reshape(x_2_grid,[],1)];

%% Real PDF (Coins)

% Centros de monedas reales
Mu = [0.329, 0.048;
      0.364, 0.187;
      0.222, 0.156];

n_def = height(Mu);

% diámetros de las monedas (2 cents of euro, 1 cent of euro)
coinsDiam = [18.75e-3; 16.25e-3; 16.25e-3];

coins_V = eye(2);

coins_D_1 = (coinsDiam(1)/2) * eye(2);
coins_D_2 = (coinsDiam(2)/2) * eye(2);
coins_D_3 = (coinsDiam(3)/2) * eye(2);

coins_S_d_1 = coins_V * coins_D_1 * coins_V' / 3;
coins_S_d_2 = coins_V * coins_D_2 * coins_V' / 3;
coins_S_d_3 = coins_V * coins_D_3 * coins_V' / 3;

Cov_1 = coins_S_d_1 * coins_S_d_1;
Cov_2 = coins_S_d_2 * coins_S_d_2;
Cov_3 = coins_S_d_3 * coins_S_d_3;

Sigma = cat(3, Cov_1, Cov_2, Cov_3);

% Real PDF
gm_dist = gmdistribution(Mu, Sigma);
Phi_x = pdf(gm_dist, Omega);

Sigma_ast_Phi = zeros(size(Sigma));
for j = 1:n_def
    % 3*Standard deviation that represents 99% of data
    Sigma_ast_Phi(:,:,j) = 3*sqrtm(Sigma(:,:,j)); 
end

% plotting
% nbDrawingSeg = 1000;
% tmp_vec = linspace(-pi, pi, nbDrawingSeg)';
% Elipse_Phi = zeros(height(tmp_vec), 2, n_def); % Elipse
% for j = 1:n_def  
%     Elipse_Phi(:,:,j) = [cos(tmp_vec), sin(tmp_vec)] * real(Sigma_ast_Phi(:,:,j)) + repmat(Mu(j,:),nbDrawingSeg,1);
% end
% 
% figure(1)
% pcolor(x_1_grid, x_2_grid, reshape(Phi_x, length(x_2), length(x_1)),...
%        "FaceColor","interp","EdgeColor","none")
% xlim([L_1_l, L_1_u])
% ylim([L_2_l, L_2_u])
% title("Real PDF",'Interpreter','latex')
% xlabel('$x_1$ [m]','Interpreter','latex')
% ylabel('$x_2$ [m]','Interpreter','latex')
% axis equal tight
% grid on
% hold on
% for j = 1:n_def
%     plot(Elipse_Phi(:,1,j), Elipse_Phi(:,2,j), "w", "LineWidth",1.3)
% end
% plot(Mu(:,1), Mu(:,2), ".")
% hold off

%% Uniform PDF as an initial guess

Phi_hat_x_1 = unifpdf(x_1, L_1_l, L_1_u);
Phi_hat_x_2 = unifpdf(x_2, L_2_l, L_2_u);

[Phi_hat_x_1_grid, Phi_hat_x_2_grid] = meshgrid(Phi_hat_x_1, Phi_hat_x_2);
Phi_hat_x = prod([reshape(Phi_hat_x_1_grid,[],1), reshape(Phi_hat_x_2_grid,[],1)], 2);

%% Cálculo de los coeficientes de Fourier para la PDF de referencia

% Coeficientes por dimensión
K = 12;

% Conjunto de valores para k_i
k_1 = (0:K-1)';
k_2 = (0:K-1)';

[k_1_grid, k_2_grid] = meshgrid(k_1, k_2);

% Conjunto de vectores índice
K_cal = [reshape(k_1_grid,1,[]); reshape(k_2_grid,1,[])];

Par_struct.K = K;
Par_struct.n = n;
Par_struct.K_cal = K_cal;
Par_struct.Omega = Omega;
Par_struct.dx_1 = dx_1;
Par_struct.dx_2 = dx_2;
Par_struct.L_i_l = L_i_l;
Par_struct.L_i_u = L_i_u;

[phi_k_reg, f_k_reg, h_k_reg] = FourierCoef_RefPDF(Phi_hat_x, Par_struct);

%% Condiciones Iniciales y parámetros

N = 100; % Número de muestras por iteración
t_f = 10;           %Tiempo final por iteración
T_s = t_f/N;                  % Tiempo de muestreo
t = (0:T_s:t_f)';   %Vector de tiempo por iteración

% Estado inicial z = [z_1; z_2; z_3; z_4] = [x_1; x_1_dot; x_2; x_2_dot]
z_0 = [Pose_0(1); 0; Pose_0(2); 0]; 

%Pre-cálculo de Lambda
p = 2; %norma 2
Lambda_k = (1 + vecnorm(K_cal, p, 1)').^(-(n + 1)/2);

% Vector de tiempo para spline a 100 Hz 
% (Frecuencia de envío de mensajes ROS2 al robot real)
t_spline = (0:0.01:t_f)';

%% Loop for the Search task
n_iter_max = 1;

% sensor uncertainty radius
r_s = 2.36e-2; 

% Registers
z_reg = zeros(N+1, 4, n_iter_max);
u_reg = zeros(N, 2, n_iter_max);
X_e_reg = zeros(N+1, 2, n_iter_max);
X_e_dot_reg = zeros(N+1, 2, n_iter_max);
phi_k_REG = zeros(K^n, 1, n_iter_max);
Phi_hat_x_reg = zeros(height(Omega), 1, n_iter_max + 1);
X_e_spline_reg = zeros(length(t_spline), 2, n_iter_max);
X_e_dot_spline_reg = zeros(length(t_spline), 2, n_iter_max);
u_spline_reg = zeros(length(t_spline) - 1, 2, n_iter_max);
% Datos de (Tiempo - Posición - Mediciones)
Data_t_Xe_V_reg = NaN(4*length(t_spline), 5, n_iter_max);
% V_Xe_reg = zeros(length(t_spline), 1, n_iter_max);

% Initializations
z_act = z_0;
phi_k_act = phi_k_reg;
Phi_hat_x_act = Phi_hat_x;

% Parameters for PDF Estimator
Par_PDF.Omega = Omega;
Par_PDF.dx_1 = dx_1;
Par_PDF.dx_2 = dx_2;
% Range of possible Number of defects to be found
Par_PDF.nbDef_range = [1, n_def + 2]; 

% Threshold definition
Par_PDF.thres_meas = 200;

Par_PDF.Prev_Data = [];
Par_PDF.Prev_numComponents = [];

% Define the dimensions of the registers for the defects found with an
% initial value (these has to be removed at the end)
Par_PDF.Prev_Mu_found = [0, 0];
Par_PDF.Prev_Sigma_found = [0, 0; 0, 0];
NoDataIterCounter = 0;

n_iter = n_iter_max;

Par_PDF.DataEscFact = 1;
% Total variation condition to find a defect
Par_PDF.Thres_Variation = max(coinsDiam) + 2*r_s + 0.001;
% Minimum axes lengths of gaussian elipses (0 = not using this constraint)
Par_PDF.MinAxisLengths = 0; % 0 m.
% Distance needed to consider more than one single defect
Par_PDF.OneClustDistLimit = max(coinsDiam) + 2*r_s + 0.007;
Par_PDF.flag_ExplorationStage = true;

% Parameters definition for the Variation constraint function

% Porcentage of max variation constraint, 
% porcentage of MaxVarCons to match with the first D_KL value
nu_p = 0.35;
% Another way to compute the MaxVarCons is define the number of times of
% Variation Threshold we want to cover per defect, \eta times.
% eta = 6;

% D_KL that matches MaxVarCons
Par_PDF.D_KL_bar_u = []; % computed in estimator 
% Little offset under Variation Threshold for numerical estability
Par_PDF.eps = 0.001;

% Maximum Variation Constraint Computation (2 ways)
Par_PDF.MaxVarCons = nu_p*(L_1 + L_2) + (1 - nu_p)*...
                     (Par_PDF.Thres_Variation - Par_PDF.eps);
% Par_PDF.MaxVarCons = eta*Par_PDF.Thres_Variation;

for i = 1:n_iter_max

    % Soluciones
    [Z, U] = UR_N100(z_act, phi_k_act); 
    Z = full(Z)';
    U = full(U)';

    % Desired Ergodic Trajectory X_e_d(t) = [x_1, x_2]
    X_e_d = [Z(:, 1), Z(:, 3)];
    X_e_d_dot = [Z(:, 2), Z(:, 4)];

    % Spline: Adding points to the trajectory to get more data from the sensor
    % and pass it to the estimator
    x_1e_d_spline = spline(t, X_e_d(:,1), t_spline);
    x_2e_d_spline = spline(t, X_e_d(:,2), t_spline);
    X_e_d_spline = [x_1e_d_spline, x_2e_d_spline];

    x_1e_dot_spline = spline(t, X_e_d_dot(:,1), t_spline);
    x_2e_dot_spline = spline(t, X_e_d_dot(:,2), t_spline);
    X_e_dot_spline = [x_1e_dot_spline, x_2e_dot_spline];

    u_1_spline = spline(t(1:end-1), U(:,1), t_spline(1:end-1));
    u_2_spline = spline(t(1:end-1), U(:,2), t_spline(1:end-1));
    u_spline = [u_1_spline, u_2_spline];
    
    % AQUI ME QUEDEEEEE XD
    % CREAR FUNCIÓN Data_t_Xe_V = ur_send_traj(t_spline, X_e_spline, parametros de nodo)

    % Measurement along the trajectory, V_Xe
    % Upsilon = a + b*pdf(gm_dist, X_e_spline); %Real PDF
    % delta = c*randn(n_points, 1); %Gaussian Noise with Variance c^2
    % V_Xe = Upsilon + delta;
    % 
    % Par_PDF.thres_meas = a + max(delta);

    % Registers
    z_reg(:,:,i) = Z;
    u_reg(:,:,i) = U;
    X_e_reg(:,:,i) = X_e_d;
    X_e_dot_reg(:,:,i) = X_e_d_dot;
    phi_k_REG(:,:,i) = phi_k_reg;
    Phi_hat_x_reg(:,:,i) = Phi_hat_x_act;
    X_e_spline_reg(:,:,i) = X_e_d_spline;
    X_e_dot_spline_reg(:,:,i) = X_e_dot_spline;
    u_spline_reg(:,:,i) = u_spline;
    Data_t_Xe_V_reg(:,:,i) = Data_t_Xe_V;
    % V_Xe_reg(:,:,i) = V_Xe;

    % PDF Estimation
    Par_PDF.iteration = i;
    Par_PDF.Prev_Phi_hat_x = Phi_hat_x_act;
    [Phi_hat_x_next, Estim_sol(i)] = PDF_Estimator(X_e_d_spline, V_Xe, Par_PDF);

    % Update Iterations Counter where No data hav been found
    NoDataIterCounter = NoDataIterCounter + Estim_sol(i).flag_NoData;

    if NoDataIterCounter == 2
        n_iter = i;
        break;
    end

    % Save D_KL from first iteration to set the exploration function
    if i == 1
        Par_PDF.D_KL_bar_u = Estim_sol(i).D_KL;
    end

    % Detect the falling edge of Exploration flag termination
    if i > 1
        falling_edge = (Estim_sol(i).flag_ExplorationStage - ...
                        Estim_sol(i-1).flag_ExplorationStage) == -1;
    else
        falling_edge = false;
    end
    % Save the Exploration flag (turned off) and the number of components 
    if falling_edge
        Par_PDF.flag_ExplorationStage = Estim_sol(i).flag_ExplorationStage;
        Par_PDF.Prev_numComponents = Estim_sol(i).numComponents;
    end

    % Save found defects if any
    Par_PDF.Prev_Mu_found = cat(1, Par_PDF.Prev_Mu_found, Estim_sol(i).Mu_found);
    Par_PDF.Prev_Sigma_found = cat(3, Par_PDF.Prev_Sigma_found, Estim_sol(i).Sigma_found);

    if Estim_sol(i).flag_done
        n_iter = i; % Save number of iterations achieved
        break;
    end
    
    % Saving Data to use it as "Previous data" in next iterations
    Par_PDF.Prev_Data = Estim_sol(i).Data;
    % Par_PDF.Prev_Priors = Estim_sol(i).Priors;
    % Par_PDF.Prev_Mu = Estim_sol(i).Mu;
    % Par_PDF.Prev_Sigma = Estim_sol(i).Sigma;
    % Par_PDF.Prev_Sigma_a = Estim_sol(i).Sigma_a;

    % Compute new Fourier coefficients for \hat{Phi}(x)
    [phi_k_reg, ~, ~] = FourierCoef_RefPDF(Phi_hat_x_next, Par_struct);

    % Update parameters for next iteration
    z_act = Z(end,:)';           % Initial condition for state
    phi_k_act = phi_k_reg;      % New target coefficients
    Phi_hat_x_act = Phi_hat_x_next;

end

% Remove the initial value (zero values) for defects found
Mu_found = Par_PDF.Prev_Mu_found(2:end, :);
Sigma_found = Par_PDF.Prev_Sigma_found(:,:,2:end);


%% Reconstrucción de distribución empírica y métrica ergódica

Varepsilon_reg = zeros(length(t), 1, n_iter);
C_x_reg = zeros(height(Omega), length(t), n_iter);

for r = 1:n_iter
    c_k = zeros(K^n, 1);
    C_x = zeros(height(Omega), 1);
    for i = 1:length(t)

        % Compute Fourier Functions and coefficients on the new position
        f_k_traj = prod(cos( K_cal'.*pi.*(X_e_reg(i,:,r) - L_i_l)./(L_i_u - L_i_l) ), 2) ./ h_k_reg ;
        c_k = c_k + (f_k_traj*T_s)/(t_f) ;

        % Ergodic metric
        Varepsilon = sum( Lambda_k .* (c_k - phi_k_REG(:,:,r)).^2 );

        % Empirical distribution reconstruction
        C_x_i = zeros(height(Omega), 1);
        for j = 1:K^n
            C_x_i = C_x_i + c_k(j)*f_k_reg(:,j);
        end

        % Se suman todas las distribuciones generadas en cada muestra
        C_x = C_x + C_x_i;

        % Se registra
        C_x_reg(:,i,r) = C_x;
        Varepsilon_reg(i,:,r) = Varepsilon;

    end

end


%% Pre-Procesing for charts

t_total = zeros(n_iter*(length(t)-1) + 1, 1);
X_e_total = zeros(n_iter*(length(t)-1) + 1, 2);
X_e_dot_total = zeros(n_iter*(length(t)-1) + 1, 2);
Varepsilon_total = zeros(n_iter*(length(t)-1) + 1, 1);
u_total = zeros(n_iter*(length(t)-1) + 1, 2);

t_spline_total = zeros(n_iter*(length(t_spline)-1) + 1, 1);
X_e_spline_total = zeros(n_iter*(length(t_spline)-1) + 1, 2);
X_e_dot_spline_total = zeros(n_iter*(length(t_spline)-1) + 1, 2);
u_spline_total = zeros(n_iter*(length(t_spline)-1) + 1, 2);
V_Xe_total = zeros(n_iter*(length(t_spline)-1) + 1, 1);

for i = 1:n_iter

    id_init = ((i - 1)*(length(t)-1) + 1); %1,101,..
    id_last = (i*(length(t)-1) + 1);        %101, 201,...

    t_total( id_init:id_last ) = (i - 1)*t(end) + t;
    X_e_total( id_init:id_last, : ) = X_e_reg(:,:,i);
    X_e_dot_total( id_init:id_last, : ) = X_e_dot_reg(:,:,i);
    Varepsilon_total( id_init:id_last, : ) = Varepsilon_reg(:,:,i);
    u_total( id_init:id_last, : ) = [u_reg(:,:,i); [NaN, NaN]];
    
    id_init_spline = ((i - 1)*(length(t_spline)-1) + 1);
    id_last_spline = (i*(length(t_spline)-1) + 1);
    t_spline_total( id_init_spline:id_last_spline ) = (i - 1)*t_spline(end) + t_spline;
    X_e_spline_total( id_init_spline:id_last_spline, : ) = X_e_spline_reg(:,:,i);
    X_e_dot_spline_total( id_init_spline:id_last_spline, : ) = X_e_dot_spline_reg(:,:,i);
    u_spline_total( id_init_spline:id_last_spline, : ) = [u_spline_reg(:,:,i); [NaN, NaN]];
    V_Xe_total( id_init_spline:id_last_spline, : ) = V_Xe_reg(:,:,i);

end


